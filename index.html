<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pictionary — French Monuments</title>
<style>
:root{--accent:#1f7ed0}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;margin:18px;background:#f6fbff;color:#0b2433}
.wrap{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:18px}
.panel{background:white;border-radius:12px;padding:14px;box-shadow:0 8px 30px rgba(20,40,60,.06);display:flex;flex-direction:column;}
h1{margin:0 0 12px;font-size:20px}
select,input,button{padding:8px;border-radius:8px;border:1px solid #e6eef9;background:transparent;font-size:13px}
.toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
#drawCanvas{background:#fff;border-radius:8px;border:1px solid #e6eef9;touch-action:none;width:100%;height:100%;}
.controls{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
.small{font-size:13px;color:#47606f}
.right-top{display:flex;justify-content:space-between;align-items:center}
button.primary{background:var(--accent);color:white;border:none}
.score{font-weight:700;font-size:18px}
.hidden {display: none;}
.room-row {display: flex; gap: 8px; align-items: center; margin: 8px 0;}
input[type="text"].roomcode {width: 90px;}
.search-row {display: flex; gap: 8px; align-items: center; margin: 8px 0;}
#searchError {color: #d02f2f; font-size: 13px; margin-left: 10px;}
.topic-display {margin: 18px 0 0 0; text-align: center;}
.topic-display strong {display: block; font-size: 17px; margin-bottom: 8px;}
.topic-display img {max-width: 90%; max-height: 180px; border-radius: 8px; border: 1px solid #e6eef9; display: block; margin: 0 auto;}
</style>
</head>
<body>
<div style="max-width:1200px;margin:0 auto"><h1>Pictionary — French Monuments</h1></div>
<div class="wrap">
<div class="panel">
<div style="display:flex;justify-content:space-between;align-items:center">
<div>
<div class="small">Mode</div>
<select id="modeSelect">
<option value="single">Singleplayer</option>
<option value="local">Local — Pass & Play</option>
<option value="duel">1v1 Duel (Online)</option>
</select>
</div>
<div>
<div class="small">Level</div>
<select id="levelSelect">
<option value="easy">Easy</option>
<option value="medium">Medium</option>
<option value="hard">Hard</option>
</select>
</div>
</div>

<div class="room-row hidden" id="duelSetup">
<button id="hostBtn">Host Game</button>
<span class="hidden" id="hostRoom">Room: <span id="roomCode"></span></span>
<input class="roomcode" id="joinCode" type="text" placeholder="Room Code"/>
<button id="joinBtn">Join</button>
<span id="duelStatus"></span>
</div>

<div class="toolbar">
<button id="randomBtn">Random Topic</button>
<button id="startBtn" class="primary">Start Round (1:30)</button>
<button id="clearBtn">Clear</button>
<button id="resetBtn">Reset</button>
</div>

<div class="search-row">
<input id="searchInput" type="text" placeholder="Search monument..." autocomplete="off" style="flex:1;">
<button id="searchBtn">Search</button>
<span id="searchError"></span>
</div>

<!-- Topic display area (will appear below Start Round) -->
<div id="topicDisplay" class="topic-display hidden">
  <strong id="topicDisplayName"></strong>
  <img id="topicDisplayImage" src="" alt="" style="display:none;">
</div>
</div>

<div class="panel" style="display:flex;flex-direction:column;">
<div class="right-top">
<div>
<div class="small">Timer</div>
<div id="timerDisplay" style="font-size:20px;font-weight:700;color:#2563eb">01:30</div>
</div>
<div style="text-align:right">
<div class="small">Score</div>
<div id="scoreDisplay" class="score">—/100</div>
</div>
</div>

<div style="flex:1">
<canvas id="drawCanvas"></canvas>
</div>

<div class="controls">
<label>Brush: <input id="brushSize" type="range" min="1" max="60" value="6"></label>
<label>Opacity: <input id="opacity" type="range" min="0.1" max="1" step="0.1" value="1"></label>
<label>Color: <input id="colorPicker" type="color" value="#000000"></label>
<button id="eraserBtn">Eraser</button>
<button id="penBtn">Pen</button>
<button id="undoBtn">Undo</button>
<button id="redoBtn">Redo</button>
</div>
</div>
</div>

<!-- Socket.io for multiplayer (CDN) -->
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
const TOPICS = {
easy: ["Eiffel Tower","Arc de Triomphe"],
medium: ["Notre-Dame de Paris","Louvre Pyramid"],
hard: ["Panthéon","Arènes de Nîmes"]
};
// Monument images
const TOPIC_IMAGES = {
  "Eiffel Tower": "https://upload.wikimedia.org/wikipedia/commons/a/a8/Tour_Eiffel_Wikimedia_Commons.jpg",
  "Arc de Triomphe": "https://cdn-imgix.headout.com/media/images/33ac22c30b1018ac1aa75c6a4c24075a-7504-Paris-ArcdeTriompheTicketswithRooftopAccess-09.jpg?auto=format&q=90&crop=faces&fit=crop",
  "Notre-Dame de Paris": "https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Notre-Dame_de_Paris_2013-07-24.jpg/330px-Notre-Dame_de_Paris_2013-07-24.jpg",
  "Louvre Pyramid": "https://cdn.britannica.com/74/250074-050-DD110B36/IM-Pei-designed-pyramid-Louvre-Paris-France.jpg",
  "Panthéon": "https://theromanguy.com/wp-content/uploads/pantheon-feature-real.jpeg",
  "Arènes de Nîmes": "https://i.familiscope.fr/1400x787/smart/2023/03/08/arenes-nimes-deposit.jpg"
};

const modeSelect = document.getElementById('modeSelect');
const levelSelect = document.getElementById('levelSelect');
const randomBtn = document.getElementById('randomBtn');
const startBtn = document.getElementById('startBtn');
const clearBtn = document.getElementById('clearBtn');
const resetBtn = document.getElementById('resetBtn');

// Search bar elements
const searchInput = document.getElementById('searchInput');
const searchBtn = document.getElementById('searchBtn');
const searchError = document.getElementById('searchError');

// Topic display elements
const topicDisplay = document.getElementById('topicDisplay');
const topicDisplayName = document.getElementById('topicDisplayName');
const topicDisplayImage = document.getElementById('topicDisplayImage');

const timerDisplay = document.getElementById('timerDisplay');
const scoreDisplay = document.getElementById('scoreDisplay');

const canvas = document.getElementById('drawCanvas');
const ctx = canvas.getContext('2d');
const brushSize = document.getElementById('brushSize');
const opacity = document.getElementById('opacity');
const colorPicker = document.getElementById('colorPicker');
const eraserBtn = document.getElementById('eraserBtn');
const penBtn = document.getElementById('penBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');

// Multiplayer UI
const duelSetup = document.getElementById('duelSetup');
const hostBtn = document.getElementById('hostBtn');
const hostRoom = document.getElementById('hostRoom');
const roomCodeEl = document.getElementById('roomCode');
const joinCode = document.getElementById('joinCode');
const joinBtn = document.getElementById('joinBtn');
const duelStatus = document.getElementById('duelStatus');

// Drawing state
let dpr = window.devicePixelRatio || 1;
function resizeCanvas(){
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr,dpr);
}
window.addEventListener('resize', ()=>{ setTimeout(resizeCanvas,50); });
setTimeout(resizeCanvas,50);

// History for undo/redo
let history = [], redoStack = [];
function pushHistory(){
    try{ history.push(canvas.toDataURL()); if(history.length>60) history.shift(); redoStack=[]; }catch(e){}
}
function restoreFromDataURL(dataURL){
    const img = new Image();
    img.onload = ()=>{ ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr); ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr); ctx.drawImage(img,0,0,canvas.width/dpr,canvas.height/dpr); };
    img.src = dataURL;
}

// Drawing tools state
let drawing=false, erasing=false, started=false, timer=null, timeLeft=90;
ctx.lineCap='round'; ctx.lineJoin='round';

function ptrPos(e){
    const rect = canvas.getBoundingClientRect();
    return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
}

canvas.addEventListener('pointerdown', (e)=>{
    if (!controlsActive()) return;
    drawing=true;
    const p=ptrPos(e);
    ctx.beginPath(); ctx.moveTo(p.x, p.y);
    pushHistory();
    if(!started) startRoundAuto();
    if (isDuelActive() && isDuelDrawingAllowed()) emitDrawEvent('begin', p);
});
canvas.addEventListener('pointermove', (e)=>{
    if(!drawing || !controlsActive()) return;
    const p=ptrPos(e);
    ctx.lineTo(p.x,p.y);
    ctx.strokeStyle = erasing ? 'rgba(0,0,0,1)' : colorPicker.value;
    ctx.lineWidth = brushSize.value;
    ctx.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
    ctx.globalAlpha = opacity.value;
    ctx.stroke();
    if (isDuelActive() && isDuelDrawingAllowed()) emitDrawEvent('draw', p);
});
canvas.addEventListener('pointerup', ()=>{ if(drawing){ drawing=false; ctx.closePath(); if (isDuelActive() && isDuelDrawingAllowed()) emitDrawEvent('end'); } });
canvas.addEventListener('pointerleave', ()=>{ if(drawing){ drawing=false; ctx.closePath(); if (isDuelActive() && isDuelDrawingAllowed()) emitDrawEvent('end'); } });

eraserBtn.addEventListener('click', ()=>{ erasing=true; eraserBtn.style.boxShadow='inset 0 0 0 2px rgba(0,0,0,.06)'; penBtn.style.boxShadow=''; });
penBtn.addEventListener('click', ()=>{ erasing=false; penBtn.style.boxShadow='inset 0 0 0 2px rgba(0,0,0,.06)'; eraserBtn.style.boxShadow=''; });

undoBtn.addEventListener('click', ()=>{
    if(!controlsActive()) return;
    if(history.length===0) return;
    const last = history.pop();
    redoStack.push(canvas.toDataURL());
    if(history.length===0){
        ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
    } else {
        restoreFromDataURL(history[history.length-1]);
    }
    if (isDuelActive() && isDuelDrawingAllowed()) emitDrawEvent('sync', null, canvas.toDataURL());
});
redoBtn.addEventListener('click', ()=>{
    if(!controlsActive()) return;
    if(redoStack.length===0) return;
    const next = redoStack.pop();
    history.push(canvas.toDataURL());
    restoreFromDataURL(next);
    if (isDuelActive() && isDuelDrawingAllowed()) emitDrawEvent('sync', null, next);
});

clearBtn.addEventListener('click', ()=>{ 
    if(!controlsActive()) return;
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr); 
    pushHistory(); 
    updateScoreDisplay(null); 
    if (isDuelActive()) emitDrawEvent('clear');
});
resetBtn.addEventListener('click', ()=>{
    clearInterval(timer); timer=null; started=false; timeLeft=90; updateTimerDisplay();
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
    history=[]; redoStack=[];
    updateScoreDisplay(null);
    if (isDuelActive()) emitDrawEvent('reset');
    if (isDuelActive()) resetDuelState();
});

// Topic selection logic
let currentTopic = "";
function setCurrentTopic(topic, level){
    currentTopic = topic;
    // Show monument display
    if(topic){
        topicDisplay.classList.remove('hidden');
        topicDisplayName.textContent = topic;
        if(TOPIC_IMAGES[topic]){
            topicDisplayImage.src = TOPIC_IMAGES[topic];
            topicDisplayImage.alt = topic;
            topicDisplayImage.style.display = 'block';
        } else {
            topicDisplayImage.src = "";
            topicDisplayImage.alt = "";
            topicDisplayImage.style.display = 'none';
        }
    } else {
        topicDisplay.classList.add('hidden');
        topicDisplayName.textContent = "";
        topicDisplayImage.src = "";
        topicDisplayImage.alt = "";
        topicDisplayImage.style.display = 'none';
    }
    updateScoreDisplay(null);
}

function pickRandomTopic(level){
    const arr = TOPICS[level] || TOPICS.easy;
    return arr[Math.floor(Math.random()*arr.length)];
}

// Random Topic button logic
randomBtn.addEventListener('click', ()=>{
    const topic = pickRandomTopic(levelSelect.value);
    setCurrentTopic(topic, levelSelect.value);
    if (isDuelActive()) emitTopicSync(topic, levelSelect.value);
});

// Search logic
function searchTopic(input, level){
    const arr = TOPICS[level] || [];
    const found = arr.find(t => t.toLowerCase() === input.toLowerCase());
    return found || null;
}
function doSearch(){
    searchError.textContent = "";
    const val = searchInput.value.trim();
    if(!val){
        searchError.textContent = "Type a monument name!";
        return;
    }
    const found = searchTopic(val, levelSelect.value);
    if(found){
        setCurrentTopic(found, levelSelect.value);
        if (isDuelActive()) emitTopicSync(found, levelSelect.value);
    }else{
        searchError.textContent = "Monument not found for this difficulty!";
    }
}
searchBtn.addEventListener('click', doSearch);
searchInput.addEventListener('keydown', (e)=>{ if(e.key==="Enter") doSearch(); });

// Show topic display when mode/level changes
levelSelect.addEventListener('change', ()=>{
    setCurrentTopic("", levelSelect.value);
});
modeSelect.addEventListener('change', ()=>{
    updateUIForMode();
    setCurrentTopic("", levelSelect.value);
});

// Timer
function updateTimerDisplay(){
    const m = Math.floor(timeLeft/60).toString().padStart(2,'0');
    const s = (timeLeft%60).toString().padStart(2,'0');
    timerDisplay.textContent = `${m}:${s}`;
}
function startRoundAuto(){
    if(started || !controlsActive()) return;
    started = true;
    timeLeft = 90;
    updateTimerDisplay();
    timer = setInterval(()=>{
        timeLeft--;
        updateTimerDisplay();
        if(timeLeft <= 0){
            clearInterval(timer); timer = null; started = false; endRound();
        }
    }, 1000);
    if (isDuelActive()) emitTimerSync('start', timeLeft);
}

startBtn.addEventListener('click', ()=>{
    if(!currentTopic){ randomBtn.click(); }
    startBtn.disabled=true; randomBtn.disabled=true; levelSelect.disabled=true; modeSelect.disabled=true;
    let showcount = 3;
    const pre = setInterval(()=>{
        startBtn.textContent = `Starting in ${showcount}s`;
        showcount--;
        if(showcount < 0){
            clearInterval(pre);
            startBtn.textContent = 'Round in progress';
            startRoundAuto();
            startBtn.disabled = false; randomBtn.disabled=false; levelSelect.disabled=false; modeSelect.disabled=false;
        }
    }, 1000);
    if (isDuelActive() && isHost()) emitTimerSync('start', 90);
});

// Score
function endRound(){
    updateScoreDisplay(Math.floor(Math.random()*51)+50);
    if (isDuelActive()) emitScoreSync(scoreDisplay.textContent);
}
function updateScoreDisplay(percent){
    if(percent === null || percent === undefined) { scoreDisplay.textContent = '—/100'; }
    else { scoreDisplay.textContent = `${percent}/100`; }
}

// UI enable/disable logic
function controlsActive(){
    if (isDuelActive() && !duelDrawingAllowed) return false;
    return started || (modeSelect.value !== 'duel');
}
function updateUIForMode(){
    if (modeSelect.value === 'duel') {
        duelSetup.classList.remove('hidden');
    } else {
        duelSetup.classList.add('hidden');
        hostRoom.classList.add('hidden');
        duelStatus.textContent = '';
    }
    const controls = document.querySelectorAll('.controls button, .controls input');
    controls.forEach(el => el.disabled = (modeSelect.value === 'duel' && !duelDrawingAllowed));
    startBtn.disabled = false;
    randomBtn.disabled = false;
    clearBtn.disabled = false;
    resetBtn.disabled = false;
    levelSelect.disabled = false;
}

// Multiplayer logic (Socket.io, minimal serverless, demo only)
const socket = io("ws://192.168.0.1:3000", { autoConnect: false });
let roomId = null, isHostFlag = false, duelDrawingAllowed = false, duelJoined = false;
function generateRoomCode() {
    return Math.random().toString(36).substr(2, 5).toUpperCase();
}
function isDuelActive() {
    return modeSelect.value === "duel" && roomId != null;
}
function isHost() {
    return isHostFlag;
}
function isDuelDrawingAllowed() {
    return duelDrawingAllowed;
}

// Host game
hostBtn.addEventListener('click', ()=>{
    roomId = generateRoomCode();
    isHostFlag = true;
    duelDrawingAllowed = false;
    hostRoom.classList.remove('hidden');
    roomCodeEl.textContent = roomId;
    duelStatus.textContent = 'Waiting for guest...';
    socket.connect();
    socket.emit('create_room', roomId);
    socket.on('room_joined', (data)=>{
        duelJoined = true;
        duelDrawingAllowed = true;
        duelStatus.textContent = 'Guest joined! Ready to play.';
        randomBtn.disabled = false;
        startBtn.disabled = false;
    });
    updateUIForMode();
});

// Join game
joinBtn.addEventListener('click', ()=>{
    roomId = joinCode.value.trim().toUpperCase();
    isHostFlag = false;
    duelDrawingAllowed = false;
    duelStatus.textContent = 'Joining room...';
    socket.connect();
    socket.emit('join_room', roomId);
    socket.on('room_joined', (data)=>{
        duelJoined = true;
        duelDrawingAllowed = true;
        duelStatus.textContent = 'Joined! Ready to play.';
        randomBtn.disabled = false;
        startBtn.disabled = false;
    });
    updateUIForMode();
});

// Drawing sync
function emitDrawEvent(type, p, imageData){
    if (!isDuelActive()) return;
    const payload = {type, p, imageData, room: roomId};
    socket.emit('draw_event', payload);
}
socket.on('draw_event', (data)=>{
    if (!isDuelActive() || !duelDrawingAllowed) return;
    if (data.type === 'begin') {
        ctx.beginPath(); ctx.moveTo(data.p.x, data.p.y);
    } else if (data.type === 'draw') {
        ctx.lineTo(data.p.x, data.p.y);
        ctx.strokeStyle = erasing ? 'rgba(0,0,0,1)' : colorPicker.value;
        ctx.lineWidth = brushSize.value;
        ctx.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
        ctx.globalAlpha = opacity.value;
        ctx.stroke();
    } else if (data.type === 'end') {
        ctx.closePath();
    } else if (data.type === 'sync' && data.imageData) {
        restoreFromDataURL(data.imageData);
    } else if (data.type === 'clear') {
        ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
        pushHistory();
    } else if (data.type === 'reset') {
        ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
        history=[]; redoStack=[];
        updateScoreDisplay(null);
        resetDuelState();
    }
});

// Topic sync
function emitTopicSync(topic, level){
    socket.emit('topic_sync', {topic, level, room: roomId});
}
socket.on('topic_sync', (data)=>{
    setCurrentTopic(data.topic, data.level);
});

// Timer sync
function emitTimerSync(action, value){
    socket.emit('timer_sync', {action, value, room: roomId});
}
socket.on('timer_sync', (data)=>{
    if (data.action === 'start') {
        timeLeft = data.value || 90;
        started = true;
        updateTimerDisplay();
        if (timer) clearInterval(timer);
        timer = setInterval(()=>{
            timeLeft--;
            updateTimerDisplay();
            if(timeLeft <= 0){
                clearInterval(timer); timer = null; started = false; endRound();
            }
        }, 1000);
    }
});

// Score sync
function emitScoreSync(score){
    socket.emit('score_sync', {score, room: roomId});
}
socket.on('score_sync', (data)=>{
    scoreDisplay.textContent = data.score;
});

// Reset duel state
function resetDuelState() {
    duelDrawingAllowed = false;
    duelJoined = false;
    started = false;
    updateUIForMode();
    duelStatus.textContent = isHostFlag ? "Waiting for guest..." : "Waiting for host...";
    roomId = null;
    hostRoom.classList.add('hidden');
}

// Window load
window.addEventListener('load', ()=>{
    setCurrentTopic("", levelSelect.value);
    updateTimerDisplay();
    updateScoreDisplay(null);
    updateUIForMode();
});
</script>
</body>
</html>
